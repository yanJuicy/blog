> 해당 게시물은 인프런 - "개발자를 위한 컴퓨터공학 1: 혼자 공부하는 컴퓨터구조 + 운영체제" 강의를 참고하여 작성한 글 입니다
> 
> [강의 링크](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)


## CPU 스케줄링 

모든 프로세스는 CPU를 필요로 하고 먼저 CPU를 사용하고 싶어한다

운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 CPU 스케줄링이라고 한다

CPU 스케줄링은 컴퓨터 성능과도 직결되는 중요한 문제다

CPU를 현명하게 배분하지 못하면 반드시 실행되어야 할 프로세스들이 실행되지 못하거나, 급하지 않은 프로세스만 실행되는 등 무질서한 상태가 발생할 수 있다



## 프로세스 우선순위

프로세스마다 우선순위가 다르다

우선순위가 높은 프로세스는 빨리 처리해야 한다

대표적으로 입출력 작업이 많은 프로세스가 있다

프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 있다

비디오 재생이나 디스크 백업 작업을 담당하는 프로세스와 같이 입출력 작업이 많은 프로세스를 입출력 집중 프로세스라 한다

복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스와 같이 CPU 작업이 많은 프로세스를 CPU 집중 프로세스라고 한다

> CPU를 이용하는 작업을 CPU 버스트(CPU burst)라 하고, 입출력장치를 기다리는 작업을 입출력 버스트(I/O burst)라고 한다

CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU를 요구했을 때, 입출력 집중 프로세스를 가능한 한 빨리 실행시켜 끊임없이 작동시키고 그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 효율적이다

입출력장치가 입출력 작업을 완료하기 전까지는 입출력 집중 프로세스는 어차피 대기 상태가 될 예정이기 때문에 먼저 처리해 버리면 다른 프로세스가 CPU를 사용할 수 있다

운영체제는 상황에 맞게 프로세스의 중요도에 맞게 CPU를 이용할 수 있도록 프로세스에 우선순위를 부여한다

우선순위가 높은 프로세스는 더 빨리, 더 자주 실행된다



## 스케줄링 큐

PCB에 우선순위가 있지만 운영체제가 일일이 모든 프로세스의 PCB를 확인하는 것은 비효율적이다

운영체제는 프로세스들에게 줄을 서서 기다릴 것을 요구한다

CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 모든 프로세스들을 모두 줄 세운다

운영체제는 이 줄을 스케줄링 큐로 구현하고 관리한다

> 스케줄링 큐는 반드시 선입선출 방식일 필요가 없다


<img width="499" alt="image" src="https://github.com/yanJuicy/blog/assets/43159295/77c44eb9-3c37-40c7-af21-07f9fd7b03e2">


운영체제가 관리하는 대부분의 자원은 이렇듯 큐로 관리된다

대표적인 큐로는 준비 큐, 대기 큐가 있다

- 쥰비 큐(ready queue)는 CPU를 이용하고 싶은 프로세스들이 서는 줄이다
- 대기 큐(waiting queue)는 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄이다

운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스들을 하나씩 꺼내어 실행하되, 그중 우선순위가 높은 프로세스를 먼저 실행한다

우선순위가 낮은 프로세스들이 먼저 큐에 있더라도 우선선위가 높은 프로세스들은 먼저 처리될 수 있다

대기 상태에 있는 프로세스도 마찬가지다

같은 장치를 요구하는 프로세스들이 같은 대기 큐에서 기다린다

하드 디스크 사용을 요구하는 프로세스는 하드 디스크 대기 큐에서 입출력 작업이 완료되기를 기다리고, 프린터 사용을 요구하는 프로세스는 프린터 대기 큐에서 입출력 작업이 완료되기를 기다린다

<img width="729" alt="image" src="https://github.com/yanJuicy/blog/assets/43159295/ecc9023c-c4f9-4bce-8586-e80dc50632c3">



## 선점형과 비선점형 스케줄링

### 선점형 스케줄링

선점이란 남보다 앞서서 차지함을 의미한다

선점형 스케줄링은 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식이다

어느 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식이다

<img width="603" alt="image" src="https://github.com/yanJuicy/blog/assets/43159295/dddc49b0-af8b-4985-a8a4-ced4cb77f0c2">

### 비선점형 스케줄링

하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식이다

비선점형 스케줄링 방식으로 자원을 이용하는 프로세스가 있다면 다른 프로세스들은 그 프로세스의 사용이 모두 끝날 때까지 기다려야 한다

<img width="613" alt="image" src="https://github.com/yanJuicy/blog/assets/43159295/caa3c18b-266b-415c-be18-88a5d17fced5">


현재 대부분의 운영체제는 선점형 스케줄링 방식을 차용한다

선점형 스케줄링과 비선점형 스케줄링은 각기 장단점이 있다

선점형 스케줄링은 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다는 장점이 있지만, 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다

비선점형 스케줄링은 오버헤드가 적지만, 당장 자원을 사용해야 하는 상황에서도 무작정 기다리는 수밖에 없다

모든 프로세스가 자원을 골고루 사용할 수 없다는 단점이 있다



## CPU 스케줄링 알고리즘

스케줄링 알고리즘의 종류는 다양하고 운영체제는 저마다 다른 스케줄링 알고리즘을 사용한다

대표적으로 다음과 같은 알고리즘이 있다

- 선입 선처리 스케줄링
- 최단 작업 우선 스케줄링
- 라운드 로빈 스케줄링
- 최소 잔여 시간 우선 스케줄링
- 우선순위 스케줄링
- 다단계 피드백 큐 스케줄링


### 선입 선처리 스케줄링

FCFS 스케줄링(First Come First Served)라고도 부른다

단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식이다

언뜻 보기에는 가장 공정해 보이지만, 때때로 프로세스들이 기다리는 시간이 매우 길어질 수 있다

호위 효과가 발생할 수 있다

짧은 시간만 실행할 프로세스여도 먼저 대기 중인 프로세스들이 끝날 때까지 무조건 기다려야 한다


### 최단 작업 우선 스케줄링

준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 방식이다

호위 효과를 방지하기 위해 CPU 사용 시간이 짧은 간단한 프로세스를 먼저 실행하면 된다

SJF 스케줄링(Shortest Job First Scheduling)이라고 한다


### 라운드 로빈 스케줄링

선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식이다

타임 슬라이스란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미한다

큐에 삽입된 프로세스들은 순서대로 CPU를 이용하되 정해진 시간만큼만 CPU를 이용한다


### 최소 잔여 시간 우선 스케줄링

SRT 스케줄링(Shortest Remaining Time) 방식은 최단 작업 우선 스케줄링 알고리즘과 라운드 로빈 알고리즘을 합친 스케줄링 방식이다

프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하고, CPU를 사용할 다음 프로세스는 남아있는 작업 시간이 가장 적은 프로세스가 선택된다



### 우선순위 스케줄링

우선순위 스케줄링(priority scheduling)은 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘이다

> 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링 된다

앞에서 본 최단 작업 우선 스케줄링, 최소 잔여 시간 우선 스케줄링 알고리즘도 우선순위 스케줄링의 일종으로 불 수 있다

우선순위 스케줄링은 근본적인 문제를 내포하고 있다

우선순위가 낮은 프로세스는 계속해서 실행이 연기될 수 있다

이를 기아 현상(starvation)이라고 한다

이를 방지하기 위한 대표적인 기법으로 에이징(aging)이 있다

이는 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식이다


### 다단계 큐 스케줄링

우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식이다

우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있으면 그다음 우선순위 큐에 있는 프로세스들을 처리한다

<img width="749" alt="image" src="https://github.com/yanJuicy/blog/assets/43159295/d5581178-93e1-4582-81b5-62ddaf6946cc">

이렇게 큐를 여러 개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해진다

큐별로 타임 슬라이스를 여러 개 지정할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용할 수도 있다


### 다단계 피드백 큐 스케줄링

다단계 큐 스케줄링과 비슷하게 동작하지만, 한 가지다 다르다

프로세스들이 큐 사이를 이동할 수 있다

새로 준비 상태가 된 프로세스가 있다면 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정 시간동안 실행된다

만약 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행된다

그리고 또 해당 큐에서 실행이 끝나지 않느다면 프로세스는 또 다음 우선순위 큐에 삽입되고, 결국 CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아진다

다단계 피드백 큐 스케줄링은 프로세스들이 큐 사이를 이동할 수 있는 방식이기 때문에 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 점차 우선순위가 높은 큐로 이동시키는 에이징 기법을 적용하여 기아 현상을 예방할 수 있다

<img width="763" alt="image" src="https://github.com/yanJuicy/blog/assets/43159295/9c3cb2a2-5ddf-41d5-a4fc-b2b6c6f8473a">

