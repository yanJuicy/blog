> 해당 게시물은 인프런 - "개발자를 위한 컴퓨터공학 1: 혼자 공부하는 컴퓨터구조 + 운영체제" 강의를 참고하여 작성한 글 입니다
> 
> [강의 링크](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)


## 동기화(synchronization)

동시다발적으로 실행되는 많은 프로세스는 서로 데이터를 주고받으며 협력하며 실행될 수 있다

이런 프로세스들은 실행 순서와 자원의 일관성을 보장해야 하기에 동기화 되어야 한다

프로세스 동기화란 프로세스들 사이의 수행 시기를 맞추는 것을 의미한다

크게 다음 두 가지를 의미한다

- 실행 순서 제어: 프로세스를 올바른 순서대로 실행하기
- 상호 배제: 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기

> 프로세스뿐만 아니라 스레드도 동기화 대상이다


### 실행 순서 제어를 위한 동기화

<img width="399" alt="image" src="https://github.com/user-attachments/assets/667442a3-adc3-4914-96a8-0e1e31162566">

위 그림과 같이 Writer 프로세스는 Book.txt 파일에 값을 저장하고, Reader 프로세스는 Book.txt 파일에 저장된 값을 읽어 들이는 프로세스고 동시에 실행 중이다

이 두 프로세스는 아무 순서대로 실행되면 안된다

Writer 프로세스가 Book.txt에 값을 저장하고 Reader 프로세스가 실행되야 한다

이렇게 동시에 실행되는 프로세스를 올바른 순서대로 실행하는 것이 실행 순서 제어를 위한 동기화다


### 상호 배제를 위한 동기화

상호 배제(mutual exclusion)는 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘이다

계좌에 잔액이 10만원이 있고 프로세스 A는 2만원을 넣고, 프로세스 B는 5만원을 넣는 작업이 동시에 실행되면 엉뚱한 결과가 나올 수 있다

<img width="657" alt="image" src="https://github.com/user-attachments/assets/bd46bfbe-7f61-46a5-80fe-782a59ff4942">

잔액이라는 데이터를 동시에 사용하는데, 프로세스 A가 끝나기도 전에 프로세스 B가 잔액을 읽어서 엉뚱한 결과가 나왔다

A와 B를 올바르게 실행하기 위해서 한 프로세스가 잔액에 접근했을 때 다른 프로세스는 기다려야 한다

<img width="645" alt="image" src="https://github.com/user-attachments/assets/7cc2d083-ae71-488b-a053-8cc51730f9b1">

이렇게 동시에 접근해서는 안 되는 자원에 동시에 접근하지 못하게 하는 것이 상호 배제를 위한 동기화다



## 생산자 소비자 문제

생산자는 물건을 계속해서 생산하는 프로세스다

소비자는 물건을 계속해서 소비하는 프로세스다

생산자와 소비자는 총합이라는 데이터를 공유한다

생산자는 버퍼에 물건을 넣은 후, 물건의 총합 변수를 1 증가시키고, 소비자는 버퍼에 물건을 빼낸 후 물건의 총합 변수를 1 감소시킨다

```Java
총합 = 10

생산자 () {
    버퍼에 데이터 삽입
    총합 변수 1 증가
}

소비자 () {
    버퍼에서 데이터 빼내기
    총합 변수 1 감소
}
```

위 상태에서 생산자, 소비자를 100,000번 동시에 실행하면 결과는 10이 아닌 다른 수가 되거나 실행 중 오류가 나타날 수도 있다

이는 생산자 프로세스와 소비자 프로세스가 제대로 동기화되지 않았기 때문이다



### 공유 자원과 임계 구역

계좌 잔액 문제와 생산자 소비자 문제의 예시에서 동시에 실행되는 프로세스들은 잔액, 총합이라는 공동의 자원을 두고 작업을 했다

이러한 자원을 공유 자원이라고 한다

공유 자원은 변수가 될 수도 있고, 파일, 입출력 장치, 보조기억장치가 될 수도 있다

이러한 자원 중 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역을 임계 구역(critical section)이라고 한다

두 개 이상의 프로세스가 임계 구역에 진입하고자 하면 둘 중 하나는 대기해야 한다

<img width="754" alt="image" src="https://github.com/user-attachments/assets/82491f32-de0d-43a0-b247-1f8f6d377ec7">

임계 구역은 두 개 이상의 프로세스가 동시에 실행되면 안 되는 영역이다

하지만 잘못된 실행으로 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우가 있다

이를 레이스 컨디션이라고 한다

운영체제는 임계 구역 문제를 아래 세 가지 원칙 하에 해결한다

- 상호배제(mutual exclusion): 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다
- 진행(progress): 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다
- 유한대기(bounded waiting): 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다



## 동기화 기법

동기화를 위한 대표적인 도구는 다음과 같다

- 뮤텍스 락
- 세마포
- 모니터


## 뮤텍스 락(Mutex Lock)

임계 구역 문제와 이를 해결하기 위한 동기화를 옷 가게에서 탈의실을 이용하는 것에 비유할 수 있다

손님들은 탈의실이라는 자원을 이용하고 탈의실 안에는 한 명씩만 들어갈 수 있다

탈의실을 열어보고 자물쇠가 걸려 있다면 탈의실 안에 사람이 있다고 판단하고 기다린다

이 자물쇠 기능을 코드로 구현한 것이 뮤텍스 락이다

임계 구역에 진입하는 프로세스는 지금 임계 구역에 있음을 알리기 위해 뮤텍스 락을 이용해 임계 구역에 자물쇠를 걸어둔다

다른 프로세스는 임계 구역이 잠겨 있다면 기다리고 잠겨 있지 않다면 임계 구역에 진입할 수 있다

뮤텍스 락의 단순한 형태는 다음과 같다

- 자물쇠 역할: 프로세스들이 공유하는 전역 변수 lock
- 임계 구역을 잠그는 역할: acquire 함수
- 임계 구역의 잠금을 해제하는 역할: release 함수

```Java
acquire() {
    while (lock == true)    // 만약 임계 구역이 잠겨 있다면
        ;                   // 임계 구역이 잠겨 있는지 반복적으로 확인
    lock = true;            // 임계 구역이 잠겨 있지 않다면 잠금
}

release() {
    lock = false;           // 임계 구역 작업이 끝났으니 잠금 해제
}


acquire();      // 자물쇠 잠겨 있는지 확인
// 임계 구역 작업 진행
release();      // 자물쇠 반환
```



