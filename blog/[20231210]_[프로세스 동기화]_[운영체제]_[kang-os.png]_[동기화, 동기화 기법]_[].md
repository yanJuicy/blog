> 해당 게시물은 인프런 - "개발자를 위한 컴퓨터공학 1: 혼자 공부하는 컴퓨터구조 + 운영체제" 강의를 참고하여 작성한 글 입니다
> 
> [강의 링크](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)


## 동기화(synchronization)

동시다발적으로 실행되는 많은 프로세스는 서로 데이터를 주고받으며 협력하며 실행될 수 있다

이런 프로세스들은 실행 순서와 자원의 일관성을 보장해야 하기에 동기화 되어야 한다

프로세스 동기화란 프로세스들 사이의 수행 시기를 맞추는 것을 의미한다

크게 다음 두 가지를 의미한다

- 실행 순서 제어: 프로세스를 올바른 순서대로 실행하기
- 상호 배제: 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기

> 프로세스뿐만 아니라 스레드도 동기화 대상이다


### 실행 순서 제어를 위한 동기화

<img width="399" alt="image" src="https://github.com/user-attachments/assets/667442a3-adc3-4914-96a8-0e1e31162566">

위 그림과 같이 Writer 프로세스는 Book.txt 파일에 값을 저장하고, Reader 프로세스는 Book.txt 파일에 저장된 값을 읽어 들이는 프로세스고 동시에 실행 중이다

이 두 프로세스는 아무 순서대로 실행되면 안된다

Writer 프로세스가 Book.txt에 값을 저장하고 Reader 프로세스가 실행되야 한다

이렇게 동시에 실행되는 프로세스를 올바른 순서대로 실행하는 것이 실행 순서 제어를 위한 동기화다


### 상호 배제를 위한 동기화

상호 배제(mutual exclusion)는 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘이다

계좌에 잔액이 10만원이 있고 프로세스 A는 2만원을 넣고, 프로세스 B는 5만원을 넣는 작업이 동시에 실행되면 엉뚱한 결과가 나올 수 있다

<img width="657" alt="image" src="https://github.com/user-attachments/assets/bd46bfbe-7f61-46a5-80fe-782a59ff4942">

잔액이라는 데이터를 동시에 사용하는데, 프로세스 A가 끝나기도 전에 프로세스 B가 잔액을 읽어서 엉뚱한 결과가 나왔다

A와 B를 올바르게 실행하기 위해서 한 프로세스가 잔액에 접근했을 때 다른 프로세스는 기다려야 한다

<img width="645" alt="image" src="https://github.com/user-attachments/assets/7cc2d083-ae71-488b-a053-8cc51730f9b1">

이렇게 동시에 접근해서는 안 되는 자원에 동시에 접근하지 못하게 하는 것이 상호 배제를 위한 동기화다



## 생산자 소비자 문제

생산자는 물건을 계속해서 생산하는 프로세스다

소비자는 물건을 계속해서 소비하는 프로세스다

생산자와 소비자는 총합이라는 데이터를 공유한다

생산자는 버퍼에 물건을 넣은 후, 물건의 총합 변수를 1 증가시키고, 소비자는 버퍼에 물건을 빼낸 후 물건의 총합 변수를 1 감소시킨다

```Java
총합 = 10

생산자 () {
    버퍼에 데이터 삽입
    총합 변수 1 증가
}

소비자 () {
    버퍼에서 데이터 빼내기
    총합 변수 1 감소
}
```

위 상태에서 생산자, 소비자를 100,000번 동시에 실행하면 결과는 10이 아닌 다른 수가 되거나 실행 중 오류가 나타날 수도 있다

이는 생산자 프로세스와 소비자 프로세스가 제대로 동기화되지 않았기 때문이다



### 공유 자원과 임계 구역

계좌 잔액 문제와 생산자 소비자 문제의 예시에서 동시에 실행되는 프로세스들은 잔액, 총합이라는 공동의 자원을 두고 작업을 했다

이러한 자원을 공유 자원이라고 한다

공유 자원은 변수가 될 수도 있고, 파일, 입출력 장치, 보조기억장치가 될 수도 있다

이러한 자원 중 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역을 임계 구역(critical section)이라고 한다

두 개 이상의 프로세스가 임계 구역에 진입하고자 하면 둘 중 하나는 대기해야 한다

<img width="754" alt="image" src="https://github.com/user-attachments/assets/82491f32-de0d-43a0-b247-1f8f6d377ec7">

임계 구역은 두 개 이상의 프로세스가 동시에 실행되면 안 되는 영역이다

하지만 잘못된 실행으로 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우가 있다

이를 레이스 컨디션이라고 한다

운영체제는 임계 구역 문제를 아래 세 가지 원칙 하에 해결한다

- 상호배제(mutual exclusion): 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다
- 진행(progress): 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다
- 유한대기(bounded waiting): 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다



## 동기화 기법

동기화를 위한 대표적인 도구는 다음과 같다

- 뮤텍스 락
- 세마포
- 모니터


## 뮤텍스 락(Mutex Lock)

임계 구역 문제와 이를 해결하기 위한 동기화를 옷 가게에서 탈의실을 이용하는 것에 비유할 수 있다

손님들은 탈의실이라는 자원을 이용하고 탈의실 안에는 한 명씩만 들어갈 수 있다

탈의실을 열어보고 자물쇠가 걸려 있다면 탈의실 안에 사람이 있다고 판단하고 기다린다

이 자물쇠 기능을 코드로 구현한 것이 뮤텍스 락이다

임계 구역에 진입하는 프로세스는 지금 임계 구역에 있음을 알리기 위해 뮤텍스 락을 이용해 임계 구역에 자물쇠를 걸어둔다

다른 프로세스는 임계 구역이 잠겨 있다면 기다리고 잠겨 있지 않다면 임계 구역에 진입할 수 있다

뮤텍스 락의 단순한 형태는 다음과 같다

- 자물쇠 역할: 프로세스들이 공유하는 전역 변수 lock
- 임계 구역을 잠그는 역할: acquire 함수
- 임계 구역의 잠금을 해제하는 역할: release 함수

```Java
acquire() {
    while (lock == true)    // 만약 임계 구역이 잠겨 있다면
        ;                   // 임계 구역이 잠겨 있는지 반복적으로 확인
    lock = true;            // 임계 구역이 잠겨 있지 않다면 잠금
}

release() {
    lock = false;           // 임계 구역 작업이 끝났으니 잠금 해제
}


acquire();      // 자물쇠 잠겨 있는지 확인
// 임계 구역 작업 진행
release();      // 자물쇠 반환
```



### 세마포(semaphore)

탈의실이 여러 개 있는 상황처럼 공유 자원이 여러 개 있을 경우 여러 개의 프로세스 각각 공유 자원에 접근이가능해야 한다

한 번에 하나의 프로세스만 이용할 수 있는 프린터 세 대가 있다고 가정한다

하나의 프린터를 사용할 수 있는 프로세스는 하나지만, 총 세 개의 프로세스가 공유 자원(세 대의 프린터)을 이용할 수 있다

세마포는 간략하게 다음과 같이 구현한다

- 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 전역 변수 S
- 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려준는 wait 함수
- 임계 구역 앞에서 기다리는 프로세스에 이제 가도 좋다고 신호를 주는 signal 함수

```Java
wait()
// 임계 구역
signal()

wait() {
    S--;
    if (S < 0) {
        add this process to Queue;
        sleep();
    }
}

signal() {
    S++;
    
    if (S <= 0) {
        remove a process p from Queue
        wakeup(p)
    }
}
```

wait 함수는 사용할 수 있는 자원이 없을 경우 해당 프로세스 상태를 대기 상태로 만들고, PCB를 세마포를 위한 대기 큐에 집어 넣는다

다른 프로세스가 임계 구역에서의 작업이 끝나고 signal 함수를 호출하면 대기 중인 프로세스를 대기 큐에서 제거하고, 프로세스 상태를 준비 상태로 변경한 뒤 준비 큐로 옮긴다



## 모니터(monitor)

세마포는 매번 임계 구역 앞뒤로 일일이 wait, signal 함수를 명시해야 한다

이 순서를 잘못 입력하면 예기치 못한 결과를 얻을 수도 있다

모니터는 세마포에 비하면 사용자가 사용하기 훨씬 편리한 도구다

모니터는 공유 자원과 공유 자원에 접근하기 위한 인터페이스를 묶어 관리한다

프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근하도록 한다

<img width="639" alt="image" src="https://github.com/user-attachments/assets/76aa401f-1e74-461f-9c44-24808c3c664d">


### 상호 배제를 위한 동기화

모니터를 통해 공유 자원에 접근하고자 하는 프로세스를 큐에 삽입하고, 큐에 삽입된 순서대로 하나씩 공유 자원을 이용하도록 한다

모니터는 공유 자원을 다루는 인터페이스에 접근하기 위한 큐(모니터에 진입하기 위한 큐)를 만들고, 모니터 안에 항상 하나의 프로세스만 들어오도록하여 상호 배제를 위한 동기화를 제공한다

<img width="1061" alt="image" src="https://github.com/user-attachments/assets/8f3851a8-963f-47fc-a726-3796a18f894f">


### 순서 제어를 위한 동기화

모니터는 세마포와 마찬가지로 실행 순서 제어를 위한 동기화도 제공한다

특정 조건을 바탕으로 프로세스를 실행하고 일시 중단하기 위해 조건 변수를 사용한다

조건 변수는 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수다

조건 변수로 wait, signal 연산을 수행할 수 있다

- wait: 호출한 프로세스의 상태를 대기 상태로 전환하고 일시적으로 조건 변수에 대한 대기 큐에 삽입하는 연산
- singal: wait을 호출하여 큐에 삽입된 프로세스의 실행을 재개하는 연산

<img width="1081" alt="image" src="https://github.com/user-attachments/assets/76698ce1-3c06-4cb4-98b3-8bf7f82162e3">

<img width="1054" alt="image" src="https://github.com/user-attachments/assets/4e2a1017-da71-4a4c-9d51-5610ea1ae268">

모니터 안에는 하나의 프로세스만이 있을 수 있다

wait을 호출했던 프로세스는 signal을 호출한 프로세스가 모니터를 떠난 뒤에 실행하거나, signal을 호출한 프로세스의 실행을 일시 중단하고 자신이 실행된 뒤 다시 signal을 호출한 프로세스의 수행을 재개한다



