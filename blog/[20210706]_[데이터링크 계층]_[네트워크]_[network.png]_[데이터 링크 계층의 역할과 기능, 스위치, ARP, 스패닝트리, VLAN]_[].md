## 데이터 링크 계층

OSI 7 Layer의 2계층으로 인접한 네트워크 노드끼리 데이터를 전송하는 기능과 절차를 제공한다

물리계층에서 발생할 수 있는 오류를 감지하고 수정한다

대표적인 프로토콜로 이더넷이 있으며 장비로는 스위치가 있다

![image](https://github.com/yanJuicy/blog/assets/43159295/b88b3499-09a6-4454-b09b-dea8733ee38e)

### 데이터 링크 계층 구성

2개의 부 계층으로 구성된다

- MAC(Media Access Control): 물리적인 부분으로 매체간의 연결방식을 제어하고 1계층과 연결한다
- LLC(Logical Link Control): 논리적인 부분으로 Frame을 만들고 3계층과 연결한다

![image](https://github.com/yanJuicy/blog/assets/43159295/2c81e472-d171-4d8b-a5ab-46442d29d950)


### MAC 주소

명령어 또는 네트워크 설정에서 확인 가능하다

![image](https://github.com/yanJuicy/blog/assets/43159295/382f21e2-60e6-4b15-9cad-2333eaf03f7c)

48bit(6 byte)로 6자리로 구성되고, 각 16진수로 표현한다

앞에 3자리는 OUI(Organization Unique Identifier)로 제조사 식별코드다

나머지 3자리는 제조사 내 일련번호다


## 주요 기능

### Framing

데이터그램을 캡슐화하여 프레임 단위로 만들고 헤더와 트레일러를 추가한다

헤더에는 목적지, 출발지 주소, 데이터 내용을 정이ㅡ한다

트레일러는 비트 에러를 감지한다

![image](https://github.com/yanJuicy/blog/assets/43159295/ad1af974-d3af-4e3f-bcce-109740a6f90d)


### 회선 제어

#### ENQ/ACK

신호간의 충돌이 발생하지 않도록 제어한다

ENQ/ACK 방법을 사용한다

이는 장비와 장비가 1:1로 연결될 때 사용한다

![image](https://github.com/yanJuicy/blog/assets/43159295/bb439356-2704-448a-a443-2b6a1cc60d6d)


#### Polling

polling은 1:N로 연결될 때 사용한다

1. select 모드: 송신자가 나머지 수신자들을 선택하여 전송한다

![image](https://github.com/yanJuicy/blog/assets/43159295/1d6ed76c-27b7-48fb-ae92-ee7e027484f7)

2. poll 모드: 수신자에게 데이터 수신 여부를 확인하여 응답을 확인하고 전송한다

![image](https://github.com/yanJuicy/blog/assets/43159295/a5e93146-63e5-4824-a2f7-16927839b74f)


### 흐름 제어

송신자와 수신자의 데이터를 처리 하는 속도 차이를 해결하기 위해 흐름을 제어한다

Layer 2에서는 Feedback 방식을 하고 Layer3, 4에서는 Rate 방식을 사용한다

#### Stop & Wait

PC2의 처리가 완료될 때까지 기다린 후 데이터를 보낸다

![image](https://github.com/yanJuicy/blog/assets/43159295/818c45b9-b078-4fe9-a9c9-7542d4d3a4cb)

PC1이 Frame을 전달했지만 ACK이 회선 문제로 응답하지 않는 경우도 있다

그럴 경우 PC1은 일정시간 후 다시 Frame을 보낸다

![image](https://github.com/yanJuicy/blog/assets/43159295/926635d2-da1e-49bf-bf05-1092ffd4a918)

Frame을 재전송하면 중복 Frame 문제가 발생할 수 있다

이럴 경우 Sequence number(1 bit)를 사용하여 동일 Frame인지 구분한다

![image](https://github.com/yanJuicy/blog/assets/43159295/719d97a8-617a-4cbe-bff0-7194d7753c07)


#### Sliding Window

개선된 방식으르 sliding window 방식이 있다

ACK 응답 없이 여러 프레임이 연속으로 전송 가능하다

Window size는 전송과 수신측의 데이터가 저장되는 버퍼의 크기다

![image](https://github.com/yanJuicy/blog/assets/43159295/5a6eddad-c80d-4bd7-8999-f0e9be8a865e)


### 오류 제어

전송 중에 오류나 손실 발생 시 수신측은 에러를 탐지 및 재전송한다

ARQ라고 한다

ARQ(Automatic Repeat Request): 프레임 손상 시 재전송이 수행되는 과정이다

#### Stop & Wait ARQ

![image](https://github.com/yanJuicy/blog/assets/43159295/4de3b629-5977-4a76-99b6-29fb9122fd1c)

- 전송 측에서 NAK을 수신하면 재전송한다
- 주어진 시간에 ACK이 안 오면 재전송한다



#### Go Back n ARQ

슬라이딩 윈도우 방식 중 하나다

![image](https://github.com/yanJuicy/blog/assets/43159295/8d4ab60e-08ea-48c7-a4b5-91d73abd12fb)

- 전송측에서 Frame 012, Frame 345를 보낸다
- 수신측에서 3번 Frame 문제가 발생한다
- 수신측에서 NAK 3으로 손상을 응답한다
- 전송측에서 Frame 345를 재전송한다


#### Selective Repeat ARQ
위 방식을 더 개선해서 손상된 Frame만 선별해서 재전송한다

알고리즘이 더 복잡해지고 스위치의 사양이 더 높아진다


## 이더넷 프레임 구조

![image](https://github.com/yanJuicy/blog/assets/43159295/60571282-6201-4054-9c21-686de736a838)

- Preamble: 이더넷 프레임의 시작과 동디화
- Dest Addr: 목적지 MAC 주소
- Source Addr: 출발지 MAC 주소
- Type: 캡슐화 되어 있는 패킷의 프로토콜 정의
- Data: 상위 계층의 데이터로 46 ~ 1500 byte의 크기, 46 byte 보다 작으면 뒤에 패딩이 붙는다
- FCS(Frame Check Sequence): 에러 체크



## 스위치와 ARP


### 스위치

2계층의 대표적인 장비로 MAC 주소를 기반으로 통신한다

허브의 단점을 보완한다
- Half Duplex -> Full Duplex
- 1 Collision Domain -> 포트별 Collision Domain

라우팅 기능이 있는 스위치는 L3 스위치라고도 부른다

스위치 사진은 다음과 같다

![image](https://github.com/yanJuicy/blog/assets/43159295/7ca41f3d-c494-49d2-b117-70b34532d9fa)


### 스위치 동작 방식

목적지 주소를 MAC 주소 테이블에서 확인하여 연결된 포트로 프레임을 전달한다

종류는 다음과 같다

1. Learning: 출발지 주소가 MAC 주소 테이블에 없으면 해당 주소를 저장한다
2. Flooding: 목적지 주소가 MAC 주소 테이블에 없으면 전체 포르토 전달한다
3. Forwarding: 목적지 주소가 MAC 주소 테이블에 있으면 해당 포르토 전달한다
4. Filtering: 출발지와 목적지가 같은 네트워크 영역이면 다른 네트워크로 전달하지 않는다
5. Aging: MAC 주소 테이블의 각 주소는 일정 시간 이후에 삭제한다

### Learning

![image](https://github.com/yanJuicy/blog/assets/43159295/54a2d212-5199-4eae-9cc3-be9777326b40)

4개의 PC는 스위치의 각 포트에 연결되고 프레임은 스위치에 전달된다

스위치는 각 포트로 유입된 프레임을 보고 MAC 주소를 테이블에 저장한다

![image](https://github.com/yanJuicy/blog/assets/43159295/90996db4-1fa0-4b5e-a197-55fb9ac93fc8)

이러면 스위치에 연결된 PC들은 학습한 상태이다


### Flooding

PC1에서 PC5로 데이터를 보내려고 한다

![image](https://github.com/yanJuicy/blog/assets/43159295/5c80d272-e43d-42af-81a6-086caaf1094c)

하지만 스위치의 테이블에는 PC5의 MAC 주소가 정보가 없다

따라서 스위치는 전체 포트로 데이터를 전달하고 PC5의 MAC 주소는 테이블에 새로 추가된다

![image](https://github.com/yanJuicy/blog/assets/43159295/dc65ecda-7b2f-47ba-aa72-a3db9ea9d3cc)



### Forwarding

목적지의 MAC 주소가 스위치의 테이블에 존재하면 원하는 PC에만 데이터를 보낼 수 있다

![image](https://github.com/yanJuicy/blog/assets/43159295/5810c2ae-39a7-4ffb-9cd6-9980b83f2f86)

PC1에서 PC5로 데이터를 보내려고 하고 PC5의 MAC 주소가 스위치의 테이블에 존재한다



### Filtering


![image](https://github.com/yanJuicy/blog/assets/43159295/0ba98989-ee7e-41cd-b516-a9f9055fb6f1)

PC1에서 PC2로 데이터를 보내려고 한다

스위치는 PC1, PC2가 같은 네트워크 영역임을 확인하여 다른 포트로 데이터를 보내지 않는다

필터링은 각 포트별 `Collision Domain`을 나누어 효율적 통신이 가능하다



### Aging

스위치의 MAC 주소 테이블은 시간이 지나면 삭제된다

테이블 저장 공간을 효율적으로 사용할 수 있다

해당 포트에 연결된 PC가 다른 포트로 옮겨진 경우도 삭제가 된다


기본 300초를 저장하고, 다시 프레임이 발생되면 다시 카운트를 시작한다



## ARP(Address Resolution Protocol)

IP 주소를 통해서 MAC 주소를 알려주는 프로토콜이다

컴퓨터 A가 컴퓨터 B에게 IP 통신을 시도하고, 통신을 수행하기 위해 목적지 MAC 주소를 알아야 한다

목적지 IP에 해당하는 MAC 주소를 알려주는 역할을 ARP가 수행한다

![image](https://github.com/yanJuicy/blog/assets/43159295/b352e89e-9065-4b34-a65a-bdcdf49559cd)

1. PC1이 PC2에게 통신을 시도한다
2. 하위 계층으로 넘어가서 PC1의 MAC 주소와 PC2의 MAC 주소로 통신해야 한다
3. PC2의 MAC 주소는 모르므로 ARP Request를 통해 MAC 주소를 요청한다
4. ARP Reply를 통해 MAC 주소를 알려준다


### 동작 과정

기본적인 구조는 다음과 같다

![image](https://github.com/yanJuicy/blog/assets/43159295/50190521-1aba-4eb0-8e8b-8631a790d1ce)

1. PC1은 동일 네트워크의 목적지인 PC2로 패킷 전송을 시도한다


2. 목적지 MAC 주소를 알기 위해 자신의 ARP Cache Table을 확인한다

`arp -a` 명령어를 통해 테이블을 확인할 수 있다
![image](https://github.com/yanJuicy/blog/assets/43159295/d5a7ae0b-f80b-49fb-9b70-2304fb788810)

PC2(172.20.10.9) 정보가 없으므로 ARP Request를 수행한다



3. ARP Cache Table에 있으면 패킷을 전송, 없으면 ARP Request를 전송한다(Broadcasting)

PC1은 목적지 IP 172.20.10.9에 대한 ARP Request를 전송한다(Broadcasting)

![image](https://github.com/yanJuicy/blog/assets/43159295/bd1a6546-1db3-4ada-9d80-fd86176ce2a1)



4. PC2에서 목적지 MAC 주소를 ARP Reply로 전달한다

IP 172.20.10.9에서 목적지 MAC 주소를 ARP Reply로 전달한다

![image](https://github.com/yanJuicy/blog/assets/43159295/bdadbbe7-a8a2-467d-8e65-1061656f33a9)


5. 목적지 MAC 주소는 ARP Cache Table에 저장되고 패킷을 전송한다

![image](https://github.com/yanJuicy/blog/assets/43159295/c3983921-3470-4f53-99dd-d8a65120b0c8)


### ARP 헤더 구조

헤더 구조는 다음과 같다

![image](https://github.com/yanJuicy/blog/assets/43159295/0fa7a179-960a-4bbe-ab26-96491fdd871e)

- Hardware Type: ARP가 동작하는 네트워크 환경
- Protocol Type: 프로토콜 종류
- Hardware Length, Protocol Length: MAC 주소 6Byte, IP 주소 4Byte
- Operation: 명령코드(1: ARP Request, 2: ARP Reply)
- Hardware Address: MAC
- Protocol Address: IP

다음은 헤더 예시다

![image](https://github.com/yanJuicy/blog/assets/43159295/e174a6ad-35dc-487c-bc59-0ab7e65828b9)


